/**
******************************************************************************
* @file : main.c
* @author : Auto-generated by STM32CubeIDE
* @brief : Main program body
******************************************************************************
* @attention
*
* Copyright (c) 2025 STMicroelectronics.
* All rights reserved.
*
* This software is licensed under terms that can be found in the LICENSE file
* in the root directory of this software component.
* If no LICENSE file comes with this software, it is provided AS-IS.
*
******************************************************************************
*/
#include "gpio.h"
#include <stddef.h>
#include "rcc.h"
#include "lpuart.h"
#include "fifo.h"
#include "interrupts.h"
#include "tim.h"
#include "led&joy.h"
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>

// Digit seelction pins
#define DIG_PORT GPIOB
#define DIG1_PIN GPIO_PIN_2
#define DIG2_PIN GPIO_PIN_3
#define DIG3_PIN GPIO_PIN_4
#define DIG4_PIN GPIO_PIN_5
#define DIG_ALL_PIN (DIG1_PIN | DIG2_PIN | DIG3_PIN | DIG4_PIN)

// Segment selection pins
#define SEG_PORT GPIOG
#define SEG_A_PIN GPIO_PIN_0
#define SEG_B_PIN GPIO_PIN_1
#define SEG_C_PIN GPIO_PIN_2
#define SEG_D_PIN GPIO_PIN_3
#define SEG_E_PIN GPIO_PIN_4
#define SEG_F_PIN GPIO_PIN_5
#define SEG_G_PIN GPIO_PIN_6
#define SEG_DP_PIN GPIO_PIN_9
#define SEG_ALL_PIN (SEG_A_PIN | SEG_B_PIN | SEG_C_PIN | SEG_D_PIN | SEG_E_PIN | SEG_F_PIN | SEG_G_PIN | SEG_DP_PIN)

// LPUART configuration
#define RX_PIN GPIO_PIN_0
#define TX_PIN GPIO_PIN_1
#define LPUART_PORT GPIOC
#define BAUDRATE 115200

// TIM configuration
#define TIME (1000 - 1) // in ms
#define PRESCALER (4 - 1) // 4MHz / 4 = 1 000KHz

static const uint16_t bcdToSegmentTable[] = {
    SEG_A_PIN | SEG_B_PIN | SEG_C_PIN | SEG_D_PIN | SEG_E_PIN | SEG_F_PIN,             // 0
    SEG_B_PIN | SEG_C_PIN,                                                             // 1
    SEG_A_PIN | SEG_B_PIN | SEG_D_PIN | SEG_E_PIN | SEG_G_PIN,                         // 2
    SEG_A_PIN | SEG_B_PIN | SEG_C_PIN | SEG_D_PIN | SEG_G_PIN,                         // 3
    SEG_B_PIN | SEG_C_PIN | SEG_F_PIN | SEG_G_PIN,                                     // 4
    SEG_A_PIN | SEG_C_PIN | SEG_D_PIN | SEG_F_PIN | SEG_G_PIN,                         // 5
    SEG_A_PIN | SEG_C_PIN | SEG_D_PIN | SEG_E_PIN | SEG_F_PIN | SEG_G_PIN,             // 6
    SEG_A_PIN | SEG_B_PIN | SEG_C_PIN,                                                 // 7
    SEG_A_PIN | SEG_B_PIN | SEG_C_PIN | SEG_D_PIN | SEG_E_PIN | SEG_F_PIN | SEG_G_PIN, // 8
    SEG_A_PIN | SEG_B_PIN | SEG_C_PIN | SEG_D_PIN | SEG_F_PIN | SEG_G_PIN              // 9
};

typedef enum {
    MENU_TOP,
    MENU_LED,
    MENU_7SEG,
    MENU_JOY,
    MENU_LPUART
} MenuLevel;

MenuLevel currentMenu = MENU_TOP;
FIFO_Typedefine fifo;
int display_number = 0;

int command_finished = 0;
int toggle_led = 0;
int led_idx = 0;
int time = 0;
int column = 0;

void lpuart_init()
{
    lpuartInitialization(LPUART1, BAUDRATE);
    lpuartEnable(LPUART1);
}

void gpio_init()
{
    int Pin = RX_PIN | TX_PIN;
    gpioInitialization(LPUART_PORT, MODE_ALTERNATE, HIGH_SPEED, PULL_NO_PUPD, AF8, Pin);
}

void segInit()
{
    uint32_t pins = SEG_A_PIN | SEG_B_PIN | SEG_C_PIN | SEG_D_PIN | SEG_E_PIN | SEG_F_PIN | SEG_G_PIN | SEG_DP_PIN;
    MODETYPES mode = MODE_OUTPUT;  // General purpose output mode
    SPEEDTYPES speed = LOW_SPEED;  // Low speed
    PULLTYPES pull = PULL_NO_PUPD; // No pull-up, pull-down
    gpioInitialization(GPIOG, mode, speed, pull, AF0, pins);
}

void digInit()
{
    uint32_t pins = DIG1_PIN | DIG2_PIN | DIG3_PIN | DIG4_PIN;
    MODETYPES mode = MODE_OUTPUT;
    SPEEDTYPES speed = LOW_SPEED;
    PULLTYPES pull = PULL_NO_PUPD;
    gpioInitialization(GPIOB, mode, speed, pull, AF0, pins);
}

void tim_init(TIM_TypeDef *tim, uint32_t period)
{
    timInitialization(tim, PRESCALER, period);
}

void init()
{
    volatile uint32_t *rcc_ahb1enr = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);
    volatile uint32_t *rcc_apb1enr = (uint32_t *)(RCC_BASE + RCC_APB1ENR2_OFFSET);
    volatile uint32_t *rcc_apb1enr1 = (uint32_t *)(RCC_BASE + RCC_APB1ENR_OFFSET);

    // Enable clocks for all GPIO ports and peripherals
    *rcc_ahb1enr |= GPIOCEN | GPIOBEN | GPIOGEN | GPIODEN | GPIOEEN;
    *rcc_apb1enr |= LPUART1EN;
    *rcc_apb1enr1 |= TIM6EN;  // Enable TIM6 clock

    // Initialize GPIOG power (required for GPIOG)
    gpioGivePowerToGPIOG();

    segInit();
    digInit();

    // Initialize LEDs
    for(int i = 0; i < led_count; i++) {
        gpioInitialization(ledports[i], MODE_OUTPUT, LOW_SPEED, PULL_NO_PUPD, AF0, ledpins[i]);
    }

    // Initialize RGB LEDs
    for(int i = 0; i < rgb_count; i++) {
        gpioInitialization(rgbports[i], MODE_OUTPUT, LOW_SPEED, PULL_NO_PUPD, AF0, rgbpins[i]);
    }

    // Initialize Joystick (input with pull-up)
    for(int i = 0; i < joy_count; i++) {
        gpioInitialization(joyports[i], MODE_INPUT, LOW_SPEED, PULL_PU, AF0, joypins[i]);
    }

    gpio_init();
    lpuart_init();
    tim_init(TIM6, TIME);
    timEnable(TIM6);  // Enable timer
    fifo_init(&fifo);
}

int parse_command_from_fifo(char *out_cmd, int *out_arg) {
    char buffer[FIFO_SIZE] = {0};
    int idx = 0;
    char c;

    do{
    	fifo_get(&fifo, &c);
    	if (idx < FIFO_SIZE - 1)
    		buffer[idx++] = c;
    } while (c != '\r' && c != '\n');
    buffer[--idx] = '\0';

    char *cmd = strtok(buffer, " \t");
    char *arg_str = strtok(NULL, " \t");

    if (!cmd) return -1;

    int i;
    for (i = 0; cmd[i]; i++) {
        out_cmd[i] = tolower((unsigned char)cmd[i]);
    }
    out_cmd[i] = '\0';

    if (arg_str) {
        char *endptr;
        long val = strtol(arg_str, &endptr, 10);

        if (*endptr == '\0') {
            if (val >= 0 && val <= 9999) {
                *out_arg = (int)val;
                return 0;
            } else {
                return -1;
            }
        }

        if (strlen(arg_str) == 1) {
            char ch = toupper((unsigned char)arg_str[0]);
            if (ch == 'R' || ch == 'G' || ch == 'B' || ch == 'C' || ch == 'U' || ch == 'L' || ch == 'D') {
                *out_arg = ch;
                return 0;
            }
            if (ch >= '0' && ch <= '7') {
                *out_arg = ch - '0';
                return 0;
            }
        }
        return -1;
    }
    *out_arg = -1;
    return 0;
}

void next_line(){
    switch (currentMenu)
    {
    case MENU_TOP:
        sendString(LPUART1, "> ");
        break;
    case MENU_LED:
        sendString(LPUART1, ">LED ");
        break;
    case MENU_7SEG:
        sendString(LPUART1, ">7SEG ");
        break;
    case MENU_JOY:
        sendString(LPUART1, ">JOY ");
        break;
    case MENU_LPUART:
        sendString(LPUART1, ">LPUART ");
        break;
    }
}

int menu_top(const char *command, int arg) {
    if (strcmp(command, "help") == 0) {
        sendString(LPUART1, "Available commands:\n\r");
        sendString(LPUART1, "help - Show this help message\n\r");
        sendString(LPUART1, "led - Control LEDs\n\r");
        sendString(LPUART1, "7seg - Control 7-segment display\n\r");
        sendString(LPUART1, "joy - Read joystick input\n\r");
        sendString(LPUART1, "lpuart - LPUART commands\n\r");
    } else if (strcmp(command, "led") == 0) {
        currentMenu = MENU_LED;
    } else if (strcmp(command, "7seg") == 0) {
        currentMenu = MENU_7SEG;
    } else if (strcmp(command, "joy") == 0) {
        currentMenu = MENU_JOY;
    } else if (strcmp(command, "lpuart") == 0) {
        currentMenu = MENU_LPUART;
    } else {
        return -1;
    }
    return 0;
}

int menu_led(const char *command, int arg) {
    if (strcmp(command, "help") == 0) {
        sendString(LPUART1, "LED> Available commands:\n\r");
        sendString(LPUART1, "Set <id>     - Turn on LED (0-7 or R,G,B)\n\r");
        sendString(LPUART1, "Clear <id>   - Turn off LED (0-7 or R,G,B)\n\r");
        sendString(LPUART1, "Blink <id>   - Blink LED 5 times\n\r");
        sendString(LPUART1, "Status <id>  - Show LED state (ON/OFF)\n\r");
        sendString(LPUART1, "Toggle <id>  - Invert LED state\n\r");
        sendString(LPUART1, "Up           - Return to top menu\n\r");
    } else if (strcmp(command, "set") == 0) {
        led_set(arg);
    } else if (strcmp(command, "clear") == 0) {
        led_clear(arg);
    } else if (strcmp(command, "blink") == 0) {
        toggle_led = 5 * 2;
        led_idx = arg;
    } else if (strcmp(command, "status") == 0) {
        led_status(arg);
    } else if (strcmp(command, "toggle") == 0) {
        led_toggle(arg);
    } else if (strcmp(command, "up") == 0) {
        currentMenu = MENU_TOP;
    } else {
        return -1;
    }
    return 0;
}

int menu_7seg(const char *command, int arg){
    if (strcmp(command, "help") == 0) {
        sendString(LPUART1, "7SEG> Available commands:\n\r");
        sendString(LPUART1, "Display <val> - Display number from 0 to 9999 on the 7-LED display\n\r");
        sendString(LPUART1, "Read          - Display on the terminal the number from 7-LED display\n\r");
        sendString(LPUART1, "Up            - Return to top menu\n\r");
    } else if (strcmp(command, "display") == 0){
            display_number = arg;
    } else if (strcmp(command, "read") == 0){
        sendString(LPUART1, "Number on 7Seg is: ");
        char num_str[6];
        snprintf(num_str, sizeof(num_str), "%04d", display_number);
        sendString(LPUART1, num_str);
        sendString(LPUART1, "\n\r");
    } else if (strcmp(command, "up") == 0) {
        currentMenu = MENU_TOP;
    } else {
        return -1;
    }
    return 0;
}

int menu_joy(const char *command, int arg){
    if (strcmp(command, "help") == 0) {
        sendString(LPUART1, "JOY> Available commands:\n\r");
        sendString(LPUART1, "Read          - Display on the terminal the current state of joystick buttons\n\r\t\t"
        		"Use L -> Left, R -> Right, U -> Up, D -> Down, or C -> ok\r\n");
        sendString(LPUART1, "Up            - Return to top menu\n\r");
    } else if (strcmp(command, "read") == 0){
        if (arg == 'L' || arg == 'R' || arg == 'U' || arg == 'D' || arg == 'C') {
            joy_read(arg);
        } else {
            sendString(LPUART1, "Invalid joystick id. Use L, R, U, D, or C\n\r");
        }
    } else if (strcmp(command, "up") == 0) {
        currentMenu = MENU_TOP;
    } else {
        return -1;
    }
    return 0;
}

int menu_lpuart(const char *command, int arg){
    if (strcmp(command, "help") == 0) {
        sendString(LPUART1, "LPUART> Available commands:\n\r");
        sendString(LPUART1, "Read          - Display baudrate, number of databits and parity bits,\n\r\t\tinformations read from registers and then calculated baudrate\n\r");
        sendString(LPUART1, "Up            - Return to top menu\n\r");
    } else if (strcmp(command, "read") == 0){
        sendString(LPUART1, "LPUART Configuration:\n\r");
        sendString(LPUART1, "Baudrate: 115200\n\r");
        sendString(LPUART1, "Data bits: 8\n\r");
        sendString(LPUART1, "Parity: None\n\r");
        sendString(LPUART1, "Stop bits: 1\n\r");

        char msg[64];
        unsigned int baudrate = getBaudrate(LPUART1);
        snprintf(msg, sizeof(msg), "BRR Register: 0x%08X\n\r", baudrate);
        sendString(LPUART1, msg);

        uint32_t calculated_baudrate = (4000000 << 8) / baudrate;
        snprintf(msg, sizeof(msg), "Calculated Baudrate: %lu\n\r", calculated_baudrate);
        sendString(LPUART1, msg);
    } else if (strcmp(command, "up") == 0) {
        currentMenu = MENU_TOP;
    } else {
        return -1;
    }
    return 0;
}

int execute_command(const char *command, int arg) {
    int result;
    switch (currentMenu)
    {
    case MENU_TOP:
        result = menu_top(command, arg);
        break;
    case MENU_LED:
        result = menu_led(command, arg);
        break;
    case MENU_7SEG:
        result = menu_7seg(command, arg);
        break;
    case MENU_JOY:
        result = menu_joy(command, arg);
        break;
    case MENU_LPUART:
        result = menu_lpuart(command, arg);
        break;
    default:
        result = -1;
    }

    if (result == -1) {
        sendString(LPUART1, "Unknown command. Type 'help' for available commands.\n\r");
    }

    return result;
}

int main(void)
{
    init();
    nvic_enable_irq(TIM6_DAC_IRQn);

    sendString(LPUART1, "Simple menu by Jakub Raj\n\r");
    sendString(LPUART1, "Write (help) to obtain more information\n\r");
    next_line();
    while (1)
    {
        char received_char = receiveChar(LPUART1);
        sendChar(LPUART1, received_char);
        if (received_char == '\r' || received_char == '\n') {
            command_finished = 1;
        }
        if (0 != fifo_put(&fifo, received_char)) {
            sendString(LPUART1, "FIFO full, command not accepted\n\r");
            next_line();
            reset_fifo(&fifo);
            command_finished = 0;
            continue;
        }
        if (command_finished)
        {
            command_finished = 0;
            char command[FIFO_SIZE] = {0};
            int arg = -1;
            if (parse_command_from_fifo(command, &arg) != 0) {
                sendString(LPUART1, "\r\n");
                sendString(LPUART1, "Invalid command\n\r");
                next_line();
                reset_fifo(&fifo);
                continue;
            }
            sendString(LPUART1, "\r\n");
            execute_command(command, arg);
            next_line();
        }
    }
}

static const int pow10[] = {1000, 100, 10, 1};

void TIM6_DACUNDER_IRQHandler(void)
{
    if (tim_check_flag(TIM6))
    {
        tim_reset_flag(TIM6);
        time++;
        time %= 1000;
        if ((0 == time % 1000) && (toggle_led > 0)){
            toggle_led--;
            led_toggle(led_idx);
        }

        gpioWrite(SEG_PORT, SEG_ALL_PIN, RESET);
        gpioWrite(DIG_PORT, DIG_ALL_PIN, RESET);

        int digit = (display_number / pow10[3-column]) % 10; // Get the current digit to display

        gpioWrite(SEG_PORT, bcdToSegmentTable[digit], SET);
        gpioWrite(DIG_PORT, DIG1_PIN << (3-column), SET);
        column++;
        column %= 4;
    }
}
